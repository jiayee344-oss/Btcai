<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BTC/USDT æ™ºèƒ½äº¤æ˜“ç³»ç»Ÿ - åŠ¨æ€TP/SL</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        /* è‡ªå®šä¹‰æ ·å¼ */
        .signal-buy {
            background: linear-gradient(135deg, rgba(16, 185, 129, 0.15), rgba(6, 78, 59, 0.1));
            border-left: 4px solid #10b981;
            border: 2px solid #10b981;
        }
        .signal-sell {
            background: linear-gradient(135deg, rgba(239, 68, 68, 0.15), rgba(127, 29, 29, 0.1));
            border-left: 4px solid #ef4444;
            border: 2px solid #ef4444;
        }
        .signal-hold {
            background: linear-gradient(135deg, rgba(156, 163, 175, 0.15), rgba(55, 65, 81, 0.1));
            border-left: 4px solid #9ca3af;
            border: 2px solid #9ca3af;
        }
        .price-hit {
            animation: pulse 1.5s infinite;
        }
        .blink {
            animation: blink 1s infinite;
        }
        .progress-bar {
            transition: width 0.5s ease;
        }
        .ai-thinking {
            background: linear-gradient(90deg, #3b82f6, #8b5cf6, #10b981);
            background-size: 200% 200%;
            animation: gradient 2s ease infinite;
        }
        
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        @keyframes gradient {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
        
        /* æ»šåŠ¨æ¡æ ·å¼ */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #1f2937;
            border-radius: 4px;
        }
        ::-webkit-scrollbar-thumb {
            background: #4b5563;
            border-radius: 4px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #6b7280;
        }
        
        /* TP/SLæ ‡è®°æ ·å¼ */
        .tp-marker {
            background: rgba(16, 185, 129, 0.2);
            border-left: 3px solid #10b981;
        }
        .sl-marker {
            background: rgba(239, 68, 68, 0.2);
            border-left: 3px solid #ef4444;
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-100">
    <div class="container mx-auto p-4 max-w-6xl">
        <!-- å¤´éƒ¨ -->
        <div class="text-center mb-8">
            <h1 class="text-4xl font-bold text-yellow-500 mb-2">
                <i class="fas fa-brain mr-2"></i>BTC/USDT æ™ºèƒ½äº¤æ˜“ç³»ç»Ÿ
            </h1>
            <p class="text-gray-400">åŠ¨æ€TP/SLåˆ†æ | åŸºäºå¸‚åœºç»“æ„ | æ™ºèƒ½é£é™©æ§åˆ¶</p>
        </div>

        <!-- ä¸»è¦å†…å®¹åŒºåŸŸ -->
        <div class="grid grid-cols-1 lg:grid-cols-3 gap-6 mb-8">
            <!-- å·¦ä¾§ï¼šå®æ—¶ä»·æ ¼ -->
            <div class="bg-gray-800 rounded-xl p-6 shadow-lg border border-gray-700">
                <div class="flex items-center justify-between mb-4">
                    <h2 class="text-xl font-semibold">
                        <i class="fas fa-chart-line text-blue-400 mr-2"></i>å®æ—¶å¸‚åœºæ•°æ®
                    </h2>
                    <span id="marketStatus" class="px-3 py-1 text-xs rounded-full bg-green-900 text-green-300">
                        <i class="fas fa-circle animate-pulse mr-1"></i>å®æ—¶æ›´æ–°
                    </span>
                </div>
                <div class="text-center py-4">
                    <div id="priceDisplay" class="text-5xl font-bold text-green-400 mb-2">$--</div>
                    <div class="text-gray-400 mb-1">BTC/USDT</div>
                    <div id="updateTime" class="text-sm text-gray-500">--:--:--</div>
                    <div class="mt-4 grid grid-cols-2 gap-3">
                        <div class="text-center p-3 bg-gray-900 rounded">
                            <div class="text-gray-400 text-sm">24Hé«˜</div>
                            <div id="high24h" class="text-green-400 font-bold text-lg">$--</div>
                        </div>
                        <div class="text-center p-3 bg-gray-900 rounded">
                            <div class="text-gray-400 text-sm">24Hä½</div>
                            <div id="low24h" class="text-red-400 font-bold text-lg">$--</div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- ä¸­é—´ï¼šAIä¿¡å· -->
            <div id="signalCard" class="signal-hold rounded-xl p-6 shadow-lg">
                <div class="flex items-center justify-between mb-4">
                    <h2 class="text-xl font-semibold">
                        <i class="fas fa-robot text-purple-400 mr-2"></i>AIäº¤æ˜“ä¿¡å·
                    </h2>
                    <div id="signalStatus" class="px-3 py-1 text-xs rounded-full bg-purple-900 text-purple-300">
                        <i class="fas fa-cog fa-spin mr-1"></i>åˆ†æä¸­...
                    </div>
                </div>
                
                <div id="aiAnalysis" class="mb-4 p-3 bg-gray-900/50 rounded-lg border border-gray-700">
                    <div class="flex items-center text-gray-400 text-sm mb-2">
                        <i class="fas fa-brain mr-2"></i>
                        <span>AIåˆ†æè¿‡ç¨‹:</span>
                    </div>
                    <div id="analysisText" class="text-sm text-gray-300">
                        æ­£åœ¨åˆ†æå¸‚åœºç»“æ„ï¼Œè®¡ç®—æ”¯æ’‘é˜»åŠ›...
                    </div>
                </div>
                
                <div class="text-center py-2">
                    <div id="signalAction" class="text-5xl font-bold mb-4">--</div>
                    <div class="text-2xl text-gray-300 mb-1">
                        ç½®ä¿¡åº¦: <span id="signalConfidence" class="text-yellow-400">--%</span>
                    </div>
                    <div id="signalTime" class="text-sm text-gray-500">--:--:--</div>
                </div>
            </div>

            <!-- å³ä¾§ï¼šåŠ¨æ€äº¤æ˜“å‚æ•° -->
            <div class="bg-gray-800 rounded-xl p-6 shadow-lg border border-gray-700">
                <h2 class="text-xl font-semibold mb-6">
                    <i class="fas fa-calculator text-red-400 mr-2"></i>åŠ¨æ€äº¤æ˜“å‚æ•°
                </h2>
                
                <div class="space-y-5">
                    <div class="p-3 bg-gray-900 rounded-lg">
                        <div class="flex justify-between items-center mb-2">
                            <span class="text-gray-400">å…¥åœºä»·æ ¼ (Entry)</span>
                            <span id="entryPrice" class="text-2xl font-bold text-white">$--</span>
                        </div>
                        <div class="text-xs text-gray-500">åŸºäºå¸‚åœºåˆ†æåŠ¨æ€ç¡®å®š</div>
                    </div>
                    
                    <div class="grid grid-cols-2 gap-4">
                        <div class="p-3 bg-green-900/30 rounded-lg border border-green-800">
                            <div class="text-green-400 font-semibold mb-1">åŠ¨æ€æ­¢ç›ˆ (TP)</div>
                            <div id="takeProfit1" class="text-xl font-bold">$--</div>
                            <div id="takeProfit2" class="text-lg text-green-300">$--</div>
                            <div class="text-xs text-gray-400 mt-1">
                                è·ç¦»: <span id="distanceTP">--%</span>
                            </div>
                        </div>
                        
                        <div class="p-3 bg-red-900/30 rounded-lg border border-red-800">
                            <div class="text-red-400 font-semibold mb-1">åŠ¨æ€æ­¢æŸ (SL)</div>
                            <div id="stopLoss" class="text-xl font-bold">$--</div>
                            <div class="text-xs text-gray-400 mt-1">
                                è·ç¦»: <span id="distanceSL">--%</span>
                            </div>
                        </div>
                    </div>
                    
                    <div class="grid grid-cols-3 gap-3 mt-2">
                        <div class="text-center p-2 bg-blue-900/20 rounded">
                            <div class="text-blue-300 text-xs">é£é™©/å›æŠ¥</div>
                            <div id="riskReward" class="font-bold">--</div>
                        </div>
                        <div class="text-center p-2 bg-yellow-900/20 rounded">
                            <div class="text-yellow-300 text-xs">ä»“ä½å¤§å°</div>
                            <div id="positionSize" class="font-bold">-- USDT</div>
                        </div>
                        <div class="text-center p-2 bg-purple-900/20 rounded">
                            <div class="text-purple-300 text-xs">ç›®æ ‡è¾¾æˆç‡</div>
                            <div id="targetProbability" class="font-bold">--%</div>
                        </div>
                    </div>
                    
                    <div class="p-3 bg-gray-900/50 rounded-lg border border-gray-700">
                        <div class="text-yellow-400 text-sm">
                            <i class="fas fa-info-circle mr-2"></i>
                            <span id="tpSlReason">TP/SLåŸºäºæ”¯æ’‘é˜»åŠ›ä½å’Œæ³¢åŠ¨ç‡åˆ†æ</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- TP/SLåˆ†æè¯¦æƒ… -->
        <div class="bg-gray-800 rounded-xl p-6 shadow-lg border border-gray-700 mb-8">
            <h2 class="text-xl font-semibold mb-6">
                <i class="fas fa-bullseye text-cyan-400 mr-2"></i>TP/SLæ™ºèƒ½åˆ†æè¯¦æƒ…
            </h2>
            
            <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
                <!-- æŠ€æœ¯åˆ†æ -->
                <div class="space-y-4">
                    <h3 class="text-lg font-semibold text-gray-300 mb-4">
                        <i class="fas fa-chart-area mr-2"></i>æŠ€æœ¯åˆ†æåŸºç¡€
                    </h3>
                    
                    <div class="grid grid-cols-2 gap-4">
                        <div class="p-3 bg-gray-900/50 rounded-lg">
                            <div class="text-gray-400 text-sm mb-1">å…³é”®é˜»åŠ›ä½</div>
                            <div id="resistanceLevels" class="text-green-400 font-bold">$--, $--</div>
                        </div>
                        <div class="p-3 bg-gray-900/50 rounded-lg">
                            <div class="text-gray-400 text-sm mb-1">å…³é”®æ”¯æ’‘ä½</div>
                            <div id="supportLevels" class="text-red-400 font-bold">$--, $--</div>
                        </div>
                    </div>
                    
                    <div class="p-4 bg-gray-900/50 rounded-lg">
                        <div class="text-yellow-400 font-semibold mb-2">
                            <i class="fas fa-ruler-combined mr-2"></i>æ³¢åŠ¨ç‡åˆ†æ
                        </div>
                        <div class="grid grid-cols-3 gap-3">
                            <div>
                                <div class="text-gray-400 text-xs">æ—¥æ³¢åŠ¨</div>
                                <div id="volatilityDaily" class="text-lg">--%</div>
                            </div>
                            <div>
                                <div class="text-gray-400 text-xs">ATR(14)</div>
                                <div id="atrValue" class="text-lg">$--</div>
                            </div>
                            <div>
                                <div class="text-gray-400 text-xs">å¸ƒæ—å¸¦å®½</div>
                                <div id="bollingerWidth" class="text-lg">--%</div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="p-4 bg-gray-900/50 rounded-lg">
                        <div class="text-blue-400 font-semibold mb-2">
                            <i class="fas fa-balance-scale mr-2"></i>å¸‚åœºç»“æ„
                        </div>
                        <div id="marketStructure" class="text-sm text-gray-300">
                            åˆ†æä¸­...
                        </div>
                    </div>
                </div>
                
                <!-- TP/SLé€»è¾‘ -->
                <div class="space-y-4">
                    <h3 class="text-lg font-semibold text-gray-300 mb-4">
                        <i class="fas fa-cogs mr-2"></i>TP/SLé€»è¾‘è¯¦è§£
                    </h3>
                    
                    <div class="p-4 tp-marker rounded-lg">
                        <div class="text-green-400 font-semibold mb-2">
                            <i class="fas fa-arrow-up mr-2"></i>æ­¢ç›ˆé€»è¾‘
                        </div>
                        <div id="tpLogic" class="text-sm text-gray-300">
                            â€¢ TP1: ç¬¬ä¸€é˜»åŠ›ä½æˆ–1å€ATR<br>
                            â€¢ TP2: ç¬¬äºŒé˜»åŠ›ä½æˆ–1.5å€ATR<br>
                            â€¢ åŸºäºæ–æ³¢é‚£å¥‘æ‰©å±•
                        </div>
                        <div class="mt-2 text-xs text-gray-400">
                            èƒœç‡ä¼°è®¡: <span id="tpSuccessRate" class="text-green-300">--%</span>
                        </div>
                    </div>
                    
                    <div class="p-4 sl-marker rounded-lg">
                        <div class="text-red-400 font-semibold mb-2">
                            <i class="fas fa-shield-alt mr-2"></i>æ­¢æŸé€»è¾‘
                        </div>
                        <div id="slLogic" class="text-sm text-gray-300">
                            â€¢ å…³é”®æ”¯æ’‘/é˜»åŠ›ä½ä¸‹æ–¹<br>
                            â€¢ æ³¢åŠ¨æ€§æ­¢æŸ: 0.5-0.7å€ATR<br>
                            â€¢ ä¿æŠ¤æ€§æ­¢æŸ: æŠ€æœ¯ç ´ä½ç‚¹
                        </div>
                        <div class="mt-2 text-xs text-gray-400">
                            ä¿æŠ¤æœ¬é‡‘æ¦‚ç‡: <span id="slProtectionRate" class="text-red-300">--%</span>
                        </div>
                    </div>
                    
                    <div class="p-4 bg-gray-900/50 rounded-lg">
                        <div class="text-purple-400 font-semibold mb-2">
                            <i class="fas fa-lightbulb mr-2"></i>æ™ºèƒ½è°ƒæ•´
                        </div>
                        <div id="dynamicAdjustment" class="text-sm text-gray-300">
                            åŸºäºå®æ—¶æ³¢åŠ¨ç‡è‡ªåŠ¨è°ƒæ•´æ­¢æŸä½ï¼Œé˜²æ­¢å¸‚åœºå™ªå£°
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- JavaScript ä»£ç  -->
        <script>
            // ==================== æ™ºèƒ½äº¤æ˜“ç³»ç»Ÿ ====================
            class SmartTradingSystem {
                constructor() {
                    this.API_BASE = 'https://www.okx.com/api/v5';
                    this.currentSymbol = 'BTC-USDT';
                    
                    // äº¤æ˜“å‚æ•°é…ç½®
                    this.TRADE_CONFIG = {
                        accountBalance: 100,        // USDTæœ¬é‡‘
                        riskPerTrade: 0.02,         // æ¯ç¬”äº¤æ˜“é£é™©2%
                        maxPositionPercent: 0.5,    // æœ€å¤§ä»“ä½50%
                        cooldownTime: 180,          // å†·å´æ—¶é—´3åˆ†é’Ÿ
                        
                        // åŠ¨æ€å‚æ•°èŒƒå›´
                        minRRRatio: 1.5,            // æœ€å°é£é™©å›æŠ¥æ¯”
                        maxRiskPercent: 0.02,       // æœ€å¤§é£é™©2%
                        volatilityMultiplier: 1.0,  // æ³¢åŠ¨ç‡ä¹˜æ•°
                    };
                    
                    // ç³»ç»ŸçŠ¶æ€
                    this.systemState = {
                        activeTrade: null,
                        signalHistory: [],
                        marketData: {
                            resistanceLevels: [],
                            supportLevels: [],
                            volatility: 0,
                            atr: 0,
                            marketStructure: 'neutral'
                        },
                        indicators: {},
                        lastUpdate: null
                    };
                    
                    // æŠ€æœ¯æŒ‡æ ‡
                    this.indicators = {
                        rsi: 50,
                        macd: { value: 0, signal: 0, histogram: 0 },
                        bollinger: { upper: 0, middle: 0, lower: 0, width: 0 },
                        fibonacci: { levels: [] }
                    };
                    
                    this.isRunning = false;
                    this.intervals = {};
                    
                    console.log('ğŸš€ SmartTradingSystem åˆå§‹åŒ–');
                }
                
                async init() {
                    try {
                        console.log('ğŸ”§ åˆå§‹åŒ–æ™ºèƒ½äº¤æ˜“ç³»ç»Ÿ...');
                        await this.testAPIConnection();
                        await this.loadMarketData();
                        this.startAutoMode();
                        console.log('âœ… ç³»ç»Ÿåˆå§‹åŒ–å®Œæˆ');
                    } catch (error) {
                        console.error('åˆå§‹åŒ–å¤±è´¥:', error);
                    }
                }
                
                // æ™ºèƒ½TP/SLè®¡ç®—
                calculateDynamicTP_SL(action, entryPrice) {
                    const marketData = this.systemState.marketData;
                    const indicators = this.indicators;
                    
                    let tp1, tp2, sl;
                    let tpLogic = '', slLogic = '';
                    
                    if (action === 'BUY') {
                        // ä½¿ç”¨é˜»åŠ›ä½æˆ–ATRè®¡ç®—æ­¢ç›ˆ
                        const resistance1 = marketData.resistanceLevels[0] || entryPrice * 1.015;
                        const resistance2 = marketData.resistanceLevels[1] || entryPrice * 1.03;
                        
                        // åŸºäºATRçš„æ­¢ç›ˆ
                        const atrBasedTP1 = entryPrice + (this.systemState.marketData.atr * 1.0);
                        const atrBasedTP2 = entryPrice + (this.systemState.marketData.atr * 1.5);
                        
                        // é€‰æ‹©æ›´æ¥è¿‘çš„ä½œä¸ºTP
                        tp1 = Math.min(resistance1, atrBasedTP1);
                        tp2 = Math.min(resistance2, atrBasedTP2);
                        
                        // ä½¿ç”¨æ”¯æ’‘ä½æˆ–ATRè®¡ç®—æ­¢æŸ
                        const support1 = marketData.supportLevels[0] || entryPrice * 0.988;
                        const support2 = marketData.supportLevels[1] || entryPrice * 0.985;
                        
                        // åŸºäºATRçš„æ­¢æŸ
                        const atrBasedSL = entryPrice - (this.systemState.marketData.atr * 0.7);
                        
                        // é€‰æ‹©æ›´è¿œçš„ä½œä¸ºSLï¼ˆä¿æŠ¤æ€§æ›´å¼ºï¼‰
                        sl = Math.min(support1, support2, atrBasedSL);
                        
                        tpLogic = `TP1: ${resistance1 ? 'ç¬¬ä¸€é˜»åŠ›ä½' : '1å€ATR'}, TP2: ${resistance2 ? 'ç¬¬äºŒé˜»åŠ›ä½' : '1.5å€ATR'}`;
                        slLogic = `SL: ${support1 ? 'å…³é”®æ”¯æ’‘ä½ä¸‹æ–¹' : '0.7å€ATR'}`;
                        
                    } else if (action === 'SELL') {
                        // ä½¿ç”¨æ”¯æ’‘ä½æˆ–ATRè®¡ç®—æ­¢ç›ˆ
                        const support1 = marketData.supportLevels[0] || entryPrice * 0.985;
                        const support2 = marketData.supportLevels[1] || entryPrice * 0.97;
                        
                        // åŸºäºATRçš„æ­¢ç›ˆ
                        const atrBasedTP1 = entryPrice - (this.systemState.marketData.atr * 1.0);
                        const atrBasedTP2 = entryPrice - (this.systemState.marketData.atr * 1.5);
                        
                        tp1 = Math.max(support1, atrBasedTP1);
                        tp2 = Math.max(support2, atrBasedTP2);
                        
                        // ä½¿ç”¨é˜»åŠ›ä½æˆ–ATRè®¡ç®—æ­¢æŸ
                        const resistance1 = marketData.resistanceLevels[0] || entryPrice * 1.012;
                        const resistance2 = marketData.resistanceLevels[1] || entryPrice * 1.015;
                        
                        const atrBasedSL = entryPrice + (this.systemState.marketData.atr * 0.7);
                        
                        sl = Math.max(resistance1, resistance2, atrBasedSL);
                        
                        tpLogic = `TP1: ${support1 ? 'ç¬¬ä¸€æ”¯æ’‘ä½' : '1å€ATR'}, TP2: ${support2 ? 'ç¬¬äºŒæ”¯æ’‘ä½' : '1.5å€ATR'}`;
                        slLogic = `SL: ${resistance1 ? 'å…³é”®é˜»åŠ›ä½ä¸Šæ–¹' : '0.7å€ATR'}`;
                    }
                    
                    // ç¡®ä¿é£é™©å›æŠ¥æ¯”åˆç†
                    const risk = Math.abs(entryPrice - sl);
                    const reward1 = Math.abs(tp1 - entryPrice);
                    const reward2 = Math.abs(tp2 - entryPrice);
                    
                    const rrRatio1 = reward1 / risk;
                    const rrRatio2 = reward2 / risk;
                    
                    // å¦‚æœé£é™©å›æŠ¥æ¯”å¤ªå°ï¼Œè°ƒæ•´æ­¢ç›ˆ
                    if (rrRatio1 < this.TRADE_CONFIG.minRRRatio) {
                        const adjustedTP1 = action === 'BUY' ? 
                            entryPrice + (risk * this.TRADE_CONFIG.minRRRatio) :
                            entryPrice - (risk * this.TRADE_CONFIG.minRRRatio);
                        
                        if (action === 'BUY' ? adjustedTP1 < tp1 : adjustedTP1 > tp1) {
                            tp1 = adjustedTP1;
                            tpLogic += ' (æ ¹æ®RRRè°ƒæ•´)';
                        }
                    }
                    
                    // è®¡ç®—ä»“ä½
                    const positionSize = this.calculatePositionSize(entryPrice, sl);
                    
                    return {
                        tp1: tp1.toFixed(2),
                        tp2: tp2.toFixed(2),
                        sl: sl.toFixed(2),
                        tpLogic,
                        slLogic,
                        positionSize: positionSize.toFixed(2),
                        positionPercent: ((positionSize / this.TRADE_CONFIG.accountBalance) * 100).toFixed(1),
                        riskReward: Math.max(rrRatio1, rrRatio2).toFixed(2),
                        riskPercent: (risk / entryPrice * 100).toFixed(2)
                    };
                }
                
                // åŸºäºé£é™©è®¡ç®—ä»“ä½
                calculatePositionSize(entryPrice, sl) {
                    const riskAmount = this.TRADE_CONFIG.accountBalance * this.TRADE_CONFIG.riskPerTrade;
                    const riskPerUnit = Math.abs(entryPrice - sl);
                    
                    let positionSize = (riskAmount / riskPerUnit) * entryPrice;
                    
                    // é™åˆ¶æœ€å¤§ä»“ä½
                    const maxPosition = this.TRADE_CONFIG.accountBalance * this.TRADE_CONFIG.maxPositionPercent;
                    positionSize = Math.min(positionSize, maxPosition);
                    
                    return positionSize;
                }
                
                // åˆ†æå¸‚åœºç»“æ„
                async analyzeMarketStructure(candles) {
                    if (!candles || candles.length < 20) return;
                    
                    // è®¡ç®—æ”¯æ’‘é˜»åŠ›ä½
                    const levels = this.findSupportResistance(candles);
                    
                    // è®¡ç®—ATR
                    const atr = this.calculateATR(candles, 14);
                    
                    // è®¡ç®—æ³¢åŠ¨ç‡
                    const volatility = this.calculateVolatility(candles);
                    
                    // åˆ†æå¸‚åœºç»“æ„
                    const structure = this.determineMarketStructure(candles);
                    
                    this.systemState.marketData = {
                        resistanceLevels: levels.resistance,
                        supportLevels: levels.support,
                        atr,
                        volatility,
                        marketStructure: structure
                    };
                    
                    // æ›´æ–°æ˜¾ç¤º
                    this.updateMarketAnalysisDisplay();
                }
                
                // å¯»æ‰¾æ”¯æ’‘é˜»åŠ›ä½
                findSupportResistance(candles) {
                    const highs = candles.map(c => c.high);
                    const lows = candles.map(c => c.low);
                    
                    // ç®€åŒ–ç‰ˆçš„æ”¯æ’‘é˜»åŠ›æ£€æµ‹
                    const resistance = [];
                    const support = [];
                    
                    // å¯»æ‰¾å±€éƒ¨é«˜ç‚¹å’Œä½ç‚¹
                    for (let i = 2; i < candles.length - 2; i++) {
                        if (highs[i] > highs[i-1] && highs[i] > highs[i-2] && 
                            highs[i] > highs[i+1] && highs[i] > highs[i+2]) {
                            resistance.push(highs[i]);
                        }
                        
                        if (lows[i] < lows[i-1] && lows[i] < lows[i-2] && 
                            lows[i] < lows[i+1] && lows[i] < lows[i+2]) {
                            support.push(lows[i]);
                        }
                    }
                    
                    // å»é‡å¹¶æ’åºï¼Œå–æœ€è¿‘çš„ä¸¤ä¸ª
                    resistance.sort((a, b) => b - a);
                    support.sort((a, b) => a - b);
                    
                    return {
                        resistance: [...new Set(resistance)].slice(0, 2),
                        support: [...new Set(support)].slice(0, 2)
                    };
                }
                
                // è®¡ç®—ATRï¼ˆå¹³å‡çœŸå®èŒƒå›´ï¼‰
                calculateATR(candles, period) {
                    if (candles.length < period) return 0;
                    
                    const trValues = [];
                    
                    for (let i = 1; i < candles.length; i++) {
                        const high = candles[i].high;
                        const low = candles[i].low;
                        const prevClose = candles[i-1].close;
                        
                        const tr = Math.max(
                            high - low,
                            Math.abs(high - prevClose),
                            Math.abs(low - prevClose)
                        );
                        trValues.push(tr);
                    }
                    
                    // è®¡ç®—ç®€å•ç§»åŠ¨å¹³å‡
                    let atr = 0;
                    for (let i = 0; i < period; i++) {
                        atr += trValues[i];
                    }
                    atr /= period;
                    
                    return atr;
                }
                
                // è®¡ç®—æ³¢åŠ¨ç‡
                calculateVolatility(candles) {
                    if (candles.length < 10) return 0;
                    
                    const returns = [];
                    for (let i = 1; i < candles.length; i++) {
                        returns.push((candles[i].close - candles[i-1].close) / candles[i-1].close);
                    }
                    
                    const mean = returns.reduce((a, b) => a + b) / returns.length;
                    const variance = returns.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / returns.length;
                    
                    return Math.sqrt(variance) * Math.sqrt(252) * 100;
                }
                
                // ç¡®å®šå¸‚åœºç»“æ„
                determineMarketStructure(candles) {
                    if (candles.length < 20) return 'neutral';
                    
                    const recent = candles.slice(-20);
                    const highs = recent.map(c => c.high);
                    const lows = recent.map(c => c.low);
                    
                    // æ£€æŸ¥æ˜¯å¦åœ¨å½¢æˆæ›´é«˜çš„é«˜ç‚¹å’Œæ›´é«˜çš„ä½ç‚¹ï¼ˆä¸Šå‡è¶‹åŠ¿ï¼‰
                    let higherHighs = 0;
                    let higherLows = 0;
                    
                    // æ£€æŸ¥æ˜¯å¦åœ¨å½¢æˆæ›´ä½çš„é«˜ç‚¹å’Œæ›´ä½çš„ä½ç‚¹ï¼ˆä¸‹é™è¶‹åŠ¿ï¼‰
                    let lowerHighs = 0;
                    let lowerLows = 0;
                    
                    for (let i = 1; i < recent.length; i++) {
                        if (highs[i] > highs[i-1]) higherHighs++;
                        if (lows[i] > lows[i-1]) higherLows++;
                        if (highs[i] < highs[i-1]) lowerHighs++;
                        if (lows[i] < lows[i-1]) lowerLows++;
                    }
                    
                    if (higherHighs > 12 && higherLows > 12) return 'uptrend';
                    if (lowerHighs > 12 && lowerLows > 12) return 'downtrend';
                    
                    // æ£€æŸ¥ç›˜æ•´
                    const range = Math.max(...highs) - Math.min(...lows);
                    const avgPrice = recent.reduce((sum, c) => sum + c.close, 0) / recent.length;
                    const consolidationRatio = range / avgPrice;
                    
                    if (consolidationRatio < 0.02) return 'consolidation';
                    
                    return 'neutral';
                }
                
                // ç”Ÿæˆæ™ºèƒ½äº¤æ˜“ä¿¡å·
                async generateSmartSignal() {
                    try {
                        // è·å–å¸‚åœºæ•°æ®
                        const price = await this.getCurrentPrice();
                        const candles = await this.getCandleData('15m', 50);
                        
                        if (!price || candles.length < 20) {
                            console.log('æ•°æ®ä¸è¶³ï¼Œè·³è¿‡ä¿¡å·ç”Ÿæˆ');
                            return;
                        }
                        
                        // åˆ†æå¸‚åœºç»“æ„
                        await this.analyzeMarketStructure(candles);
                        
                        // è®¡ç®—æŠ€æœ¯æŒ‡æ ‡
                        await this.calculateTechnicalIndicators(candles);
                        
                        // ç»¼åˆåˆ¤æ–­
                        const signal = this.evaluateMarketConditions(price);
                        
                        if (signal.action !== 'HOLD') {
                            // åŠ¨æ€è®¡ç®—TP/SL
                            const tradeParams = this.calculateDynamicTP_SL(signal.action, price);
                            
                            // åˆ›å»ºäº¤æ˜“è®°å½•
                            const trade = {
                                id: `trade_${Date.now()}`,
                                action: signal.action,
                                price: price.toFixed(2),
                                ...tradeParams,
                                reason: signal.reason,
                                timestamp: new Date().toISOString(),
                                status: 'active'
                            };
                            
                            this.systemState.activeTrade = trade;
                            this.displaySignal(trade);
                            
                            console.log(`æ™ºèƒ½ä¿¡å·ç”Ÿæˆ: ${signal.action}`, tradeParams);
                        }
                        
                    } catch (error) {
                        console.error('ç”Ÿæˆä¿¡å·å¤±è´¥:', error);
                    }
                }
                
                // è¯„ä¼°å¸‚åœºæ¡ä»¶
                evaluateMarketConditions(currentPrice) {
                    const marketData = this.systemState.marketData;
                    const indicators = this.indicators;
                    
                    let action = 'HOLD';
                    let reason = '';
                    let confidence = 0.5;
                    
                    // ç»“åˆå¤šä¸ªå› ç´ åˆ¤æ–­
                    if (marketData.marketStructure === 'uptrend') {
                        if (indicators.rsi < 40) {
                            action = 'BUY';
                            reason = 'ä¸Šå‡è¶‹åŠ¿ä¸­çš„RSIå›è°ƒä¹°å…¥æœºä¼š';
                            confidence = 0.65;
                        }
                    } else if (marketData.marketStructure === 'downtrend') {
                        if (indicators.rsi > 60) {
                            action = 'SELL';
                            reason = 'ä¸‹é™è¶‹åŠ¿ä¸­çš„RSIåå¼¹å–å‡ºæœºä¼š';
                            confidence = 0.65;
                        }
                    } else if (marketData.marketStructure === 'consolidation') {
                        // ç›˜æ•´åŒºé—´äº¤æ˜“
                        const resistance = marketData.resistanceLevels[0];
                        const support = marketData.supportLevels[0];
                        
                        if (resistance && support) {
                            const range = resistance - support;
                            const position = (currentPrice - support) / range;
                            
                            if (position < 0.3) {
                                action = 'BUY';
                                reason = 'æ¥è¿‘ç›˜æ•´åŒºé—´ä¸‹æ²¿ä¹°å…¥';
                                confidence = 0.6;
                            } else if (position > 0.7) {
                                action = 'SELL';
                                reason = 'æ¥è¿‘ç›˜æ•´åŒºé—´ä¸Šæ²¿å–å‡º';
                                confidence = 0.6;
                            }
                        }
                    }
                    
                    // æ³¢åŠ¨ç‡è¿‡æ»¤
                    if (marketData.volatility > 5) {
                        confidence *= 0.9;
                        reason += ` | é«˜æ³¢åŠ¨ç‡ç¯å¢ƒ`;
                    }
                    
                    return { action, reason, confidence: confidence.toFixed(2) };
                }
                
                // è®¡ç®—æŠ€æœ¯æŒ‡æ ‡
                async calculateTechnicalIndicators(candles) {
                    // è®¡ç®—RSI
                    this.indicators.rsi = this.calculateRSI(candles.map(c => c.close));
                    
                    // è®¡ç®—å¸ƒæ—å¸¦
                    this.indicators.bollinger = this.calculateBollingerBands(candles);
                    
                    console.log('æŠ€æœ¯æŒ‡æ ‡æ›´æ–°:', this.indicators);
                }
                
                // è®¡ç®—RSI
                calculateRSI(prices) {
                    if (prices.length < 14) return 50;
                    
                    let gains = 0;
                    let losses = 0;
                    
                    for (let i = 1; i < 14; i++) {
                        const change = prices[i] - prices[i - 1];
                        if (change > 0) gains += change;
                        else losses += Math.abs(change);
                    }
                    
                    let avgGain = gains / 13;
                    let avgLoss = losses / 13;
                    
                    for (let i = 14; i < prices.length; i++) {
                        const change = prices[i] - prices[i - 1];
                        const gain = change > 0 ? change : 0;
                        const loss = change < 0 ? Math.abs(change) : 0;
                        
                        avgGain = (avgGain * 13 + gain) / 14;
                        avgLoss = (avgLoss * 13 + loss) / 14;
                    }
                    
                    if (avgLoss === 0) return 100;
                    const rs = avgGain / avgLoss;
                    return 100 - (100 / (1 + rs));
                }
                
                // è®¡ç®—å¸ƒæ—å¸¦
                calculateBollingerBands(candles) {
                    if (candles.length < 20) return { upper: 0, middle: 0, lower: 0, width: 0 };
                    
                    const closes = candles.slice(-20).map(c => c.close);
                    const middle = closes.reduce((a, b) => a + b) / closes.length;
                    
                    const variance = closes.reduce((sum, price) => {
                        return sum + Math.pow(price - middle, 2);
                    }, 0) / closes.length;
                    
                    const stdDev = Math.sqrt(variance);
                    const upper = middle + (stdDev * 2);
                    const lower = middle - (stdDev * 2);
                    const width = ((upper - lower) / middle) * 100;
                    
                    return { upper, middle, lower, width: width.toFixed(2) };
                }
                
                // æ›´æ–°å¸‚åœºåˆ†ææ˜¾ç¤º
                updateMarketAnalysisDisplay() {
                    const data = this.systemState.marketData;
                    
                    // æ›´æ–°æ”¯æ’‘é˜»åŠ›æ˜¾ç¤º
                    const resistanceElement = document.getElementById('resistanceLevels');
                    const supportElement = document.getElementById('supportLevels');
                    
                    if (resistanceElement) {
                        resistanceElement.textContent = data.resistanceLevels.map(l => `$${l.toFixed(2)}`).join(', ');
                    }
                    
                    if (supportElement) {
                        supportElement.textContent = data.supportLevels.map(l => `$${l.toFixed(2)}`).join(', ');
                    }
                    
                    // æ›´æ–°æ³¢åŠ¨ç‡æ˜¾ç¤º
                    const volatilityElement = document.getElementById('volatilityDaily');
                    const atrElement = document.getElementById('atrValue');
                    const bollingerElement = document.getElementById('bollingerWidth');
                    
                    if (volatilityElement) {
                        volatilityElement.textContent = `${data.volatility.toFixed(2)}%`;
                    }
                    
                    if (atrElement) {
                        atrElement.textContent = `$${data.atr.toFixed(2)}`;
                    }
                    
                    if (bollingerElement) {
                        bollingerElement.textContent = `${this.indicators.bollinger.width}%`;
                    }
                    
                    // æ›´æ–°å¸‚åœºç»“æ„æ˜¾ç¤º
                    const structureElement = document.getElementById('marketStructure');
                    if (structureElement) {
                        structureElement.textContent = this.getMarketStructureText(data.marketStructure);
                    }
                }
                
                getMarketStructureText(structure) {
                    const texts = {
                        'uptrend': 'ğŸ“ˆ ä¸Šå‡è¶‹åŠ¿ - ä»·æ ¼å½¢æˆæ›´é«˜çš„é«˜ç‚¹å’Œæ›´é«˜çš„ä½ç‚¹',
                        'downtrend': 'ğŸ“‰ ä¸‹é™è¶‹åŠ¿ - ä»·æ ¼å½¢æˆæ›´ä½çš„é«˜ç‚¹å’Œæ›´ä½çš„ä½ç‚¹',
                        'consolidation': 'âš–ï¸ ç›˜æ•´åŒºé—´ - ä»·æ ¼åœ¨ç‰¹å®šèŒƒå›´å†…æ³¢åŠ¨',
                        'neutral': 'âšª ä¸­æ€§å¸‚åœº - æ— æ˜æ˜¾è¶‹åŠ¿'
                    };
                    return texts[structure] || 'åˆ†æä¸­...';
                }
                
                // æ˜¾ç¤ºä¿¡å·
                displaySignal(trade) {
                    const card = document.getElementById('signalCard');
                    const actionElement = document.getElementById('signalAction');
                    const analysisElement = document.getElementById('analysisText');
                    
                    if (card) {
                        card.className = 'rounded-xl p-6 shadow-lg border-2';
                        
                        if (trade.action === 'BUY') {
                            card.classList.add('signal-buy');
                            if (actionElement) {
                                actionElement.innerHTML = 'ğŸ”¼ BUY';
                                actionElement.className = 'text-5xl font-bold text-green-400 mb-4';
                            }
                        } else {
                            card.classList.add('signal-sell');
                            if (actionElement) {
                                actionElement.innerHTML = 'ğŸ”½ SELL';
                                actionElement.className = 'text-5xl font-bold text-red-400 mb-4';
                            }
                        }
                    }
                    
                    if (analysisElement) {
                        analysisElement.textContent = trade.reason;
                    }
                    
                    // æ›´æ–°äº¤æ˜“å‚æ•°
                    this.updateTradeParameters(trade);
                    
                    // æ›´æ–°TP/SLé€»è¾‘
                    this.updateTP_SLLogic(trade);
                }
                
                updateTradeParameters(trade) {
                    const entryElement = document.getElementById('entryPrice');
                    const tp1Element = document.getElementById('takeProfit1');
                    const tp2Element = document.getElementById('takeProfit2');
                    const slElement = document.getElementById('stopLoss');
                    const rrElement = document.getElementById('riskReward');
                    const positionElement = document.getElementById('positionSize');
                    const tpSlReasonElement = document.getElementById('tpSlReason');
                    
                    if (entryElement) entryElement.textContent = `$${trade.price}`;
                    if (tp1Element) tp1Element.textContent = `$${trade.tp1}`;
                    if (tp2Element) tp2Element.textContent = `$${trade.tp2}`;
                    if (slElement) slElement.textContent = `$${trade.sl}`;
                    if (rrElement) rrElement.textContent = `${trade.riskReward}:1`;
                    if (positionElement) positionElement.textContent = `${trade.positionSize} USDT`;
                    if (tpSlReasonElement) tpSlReasonElement.textContent = `åŠ¨æ€TP/SL - é£é™©: ${trade.riskPercent}%`;
                    
                    // è®¡ç®—å¹¶æ˜¾ç¤ºè·ç¦»
                    const currentPrice = parseFloat(this.currentPrice || trade.price);
                    const tpDistance = ((parseFloat(trade.tp1) - currentPrice) / currentPrice * 100).toFixed(2);
                    const slDistance = ((currentPrice - parseFloat(trade.sl)) / currentPrice * 100).toFixed(2);
                    
                    const tpDistanceElement = document.getElementById('distanceTP');
                    const slDistanceElement = document.getElementById('distanceSL');
                    
                    if (tpDistanceElement) tpDistanceElement.textContent = `${tpDistance}%`;
                    if (slDistanceElement) slDistanceElement.textContent = `${slDistance}%`;
                }
                
                updateTP_SLLogic(trade) {
                    const tpLogicElement = document.getElementById('tpLogic');
                    const slLogicElement = document.getElementById('slLogic');
                    
                    if (tpLogicElement) {
                        tpLogicElement.innerHTML = `
                            â€¢ TP1 ($${trade.tp1}): ç¬¬ä¸€ç›®æ ‡ä½<br>
                            â€¢ TP2 ($${trade.tp2}): ç¬¬äºŒç›®æ ‡ä½<br>
                            â€¢ åŸºäº: ${trade.tpLogic}
                        `;
                    }
                    
                    if (slLogicElement) {
                        slLogicElement.innerHTML = `
                            â€¢ SL ($${trade.sl}): ä¿æŠ¤æ€§æ­¢æŸ<br>
                            â€¢ é€»è¾‘: ${trade.slLogic}<br>
                            â€¢ é£é™©: ${trade.riskPercent}% ä»“ä½
                        `;
                    }
                }
                
                // APIæ–¹æ³•
                async getCurrentPrice() {
                    try {
                        const response = await fetch(`${this.API_BASE}/market/ticker?instId=${this.currentSymbol}`);
                        const data = await response.json();
                        
                        if (data.code === '0' && data.data && data.data[0]) {
                            this.currentPrice = parseFloat(data.data[0].last);
                            this.updatePriceDisplay();
                            return this.currentPrice;
                        }
                    } catch (error) {
                        console.error('è·å–ä»·æ ¼å¤±è´¥:', error);
                    }
                    return null;
                }
                
                async getCandleData(interval = '15m', limit = 50) {
                    try {
                        const response = await fetch(
                            `${this.API_BASE}/market/candles?instId=${this.currentSymbol}&bar=${interval}&limit=${limit}`
                        );
                        const data = await response.json();
                        
                        if (data.code === '0' && data.data) {
                            return data.data.map(candle => ({
                                timestamp: parseInt(candle[0]),
                                open: parseFloat(candle[1]),
                                high: parseFloat(candle[2]),
                                low: parseFloat(candle[3]),
                                close: parseFloat(candle[4]),
                                volume: parseFloat(candle[5])
                            })).reverse();
                        }
                    } catch (error) {
                        console.error('è·å–Kçº¿æ•°æ®å¤±è´¥:', error);
                    }
                    return [];
                }
                
                async testAPIConnection() {
                    try {
                        const response = await fetch(`${this.API_BASE}/public/time`);
                        const data = await response.json();
                        if (data.code === '0') {
                            console.log('âœ… APIè¿æ¥æ­£å¸¸');
                            return true;
                        }
                    } catch (error) {
                        console.error('APIè¿æ¥å¤±è´¥:', error);
                    }
                    return false;
                }
                
                async loadMarketData() {
                    await this.getCurrentPrice();
                    const candles = await this.getCandleData('15m', 50);
                    await this.analyzeMarketStructure(candles);
                }
                
                updatePriceDisplay() {
                    const priceElement = document.getElementById('priceDisplay');
                    const timeElement = document.getElementById('updateTime');
                    
                    if (priceElement && this.currentPrice) {
                        priceElement.textContent = `$${this.currentPrice.toLocaleString('en-US', {
                            minimumFractionDigits: 2,
                            maximumFractionDigits: 2
                        })}`;
                    }
                    
                    if (timeElement) {
                        timeElement.textContent = new Date().toLocaleTimeString('zh-CN');
                    }
                }
                
                startAutoMode() {
                    this.isRunning = true;
                    
                    // æ¯10ç§’æ›´æ–°ä»·æ ¼
                    this.intervals.priceUpdate = setInterval(async () => {
                        await this.getCurrentPrice();
                    }, 10000);
                    
                    // æ¯30ç§’æ£€æŸ¥å¸‚åœºæ¡ä»¶
                    this.intervals.signalCheck = setInterval(async () => {
                        if (!this.systemState.activeTrade) {
                            await this.generateSmartSignal();
                        }
                    }, 30000);
                    
                    // æ¯5åˆ†é’Ÿé‡æ–°åˆ†æå¸‚åœºç»“æ„
                    this.intervals.marketAnalysis = setInterval(async () => {
                        await this.loadMarketData();
                    }, 300000);
                    
                    console.log('ğŸš€ æ™ºèƒ½äº¤æ˜“ç³»ç»Ÿå·²å¯åŠ¨');
                }
                
                stopAutoMode() {
                    this.isRunning = false;
                    Object.values(this.intervals).forEach(interval => {
                        if (interval) clearInterval(interval);
                    });
                    console.log('ğŸ›‘ ç³»ç»Ÿå·²åœæ­¢');
                }
            }

            // ==================== å…¨å±€å‡½æ•° ====================
            let smartSystem = null;

            function initSystem() {
                if (!smartSystem) {
                    smartSystem = new SmartTradingSystem();
                    smartSystem.init();
                }
                return smartSystem;
            }

            function manualGenerateSignal() {
                if (smartSystem) {
                    smartSystem.generateSmartSignal();
                    alert('æ­£åœ¨ç”Ÿæˆæ™ºèƒ½ä¿¡å·...');
                } else {
                    alert('ç³»ç»Ÿæœªåˆå§‹åŒ–');
                }
            }

            function refreshMarketData() {
                if (smartSystem) {
                    smartSystem.loadMarketData();
                    alert('å¸‚åœºæ•°æ®åˆ·æ–°ä¸­...');
                } else {
                    alert('ç³»ç»Ÿæœªåˆå§‹åŒ–');
                }
            }

            function showTP_SLAnalysis() {
                if (smartSystem && smartSystem.systemState.activeTrade) {
                    const trade = smartSystem.systemState.activeTrade;
                    const analysis = `
ğŸ“Š TP/SLåˆ†æè¯¦æƒ…:
--------------------
å…¥åœºä»·æ ¼: $${trade.price}
TP1: $${trade.tp1} (ç›®æ ‡1)
TP2: $${trade.tp2} (ç›®æ ‡2)
SL: $${trade.sl} (æ­¢æŸ)

ğŸ“ˆ é€»è¾‘åˆ†æ:
${trade.tpLogic}
${trade.slLogic}

ğŸ’° é£é™©ç®¡ç†:
é£é™©/å›æŠ¥: ${trade.riskReward}:1
ä»“ä½å¤§å°: ${trade.positionSize} USDT
é£é™©å æ¯”: ${trade.riskPercent}%

ğŸ’¡ å»ºè®®:
1. è¾¾åˆ°TP1åï¼Œç§»åŠ¨æ­¢æŸè‡³ä¿æœ¬ä»·
2. å‰©ä½™ä»“ä½çœ‹å‘TP2
3. ä¸¥æ ¼æŒ‰SLæ‰§è¡Œï¼Œä¿æŠ¤æœ¬é‡‘
                    `;
                    alert(analysis);
                } else {
                    alert('å½“å‰æ²¡æœ‰æ´»è·ƒäº¤æ˜“');
                }
            }

            // é¡µé¢åŠ è½½åˆå§‹åŒ–
            document.addEventListener('DOMContentLoaded', function() {
                console.log('ğŸ“ˆ BTC/USDT æ™ºèƒ½äº¤æ˜“ç³»ç»ŸåŠ è½½ä¸­...');
                
                const welcomeMsg = `
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘   ğŸ§  BTC/USDT æ™ºèƒ½äº¤æ˜“ç³»ç»Ÿ               â•‘
â•‘                                            â•‘
â•‘   æ ¸å¿ƒç‰¹æ€§:                               â•‘
â•‘   â€¢ åŠ¨æ€TP/SLåˆ†æï¼Œéå›ºå®šç™¾åˆ†æ¯”          â•‘
â•‘   â€¢ åŸºäºå¸‚åœºç»“æ„å’ŒæŠ€æœ¯åˆ†æ              â•‘
â•‘   â€¢ æ™ºèƒ½æ”¯æ’‘é˜»åŠ›ä½æ£€æµ‹                  â•‘
â•‘   â€¢ ATRæ³¢åŠ¨ç‡è‡ªé€‚åº”æ­¢æŸ                â•‘
â•‘   â€¢ å®æ—¶å¸‚åœºç»“æ„åˆ†æ                    â•‘
â•‘                                            â•‘
â•‘   æŠ€æœ¯åŸºç¡€:                               â•‘
â•‘   â€¢ æ”¯æ’‘/é˜»åŠ›ä½åˆ†æ                      â•‘
â•‘   â€¢ ATRå¹³å‡çœŸå®èŒƒå›´                     â•‘
â•‘   â€¢ å¸‚åœºè¶‹åŠ¿åˆ¤æ–­                        â•‘
â•‘   â€¢ é£é™©å›æŠ¥æ¯”ä¼˜åŒ–                      â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                `;
                console.log(welcomeMsg);
                
                // åˆå§‹åŒ–ç³»ç»Ÿ
                smartSystem = initSystem();
                
                // æš´éœ²åˆ°å…¨å±€
                window.smartSystem = smartSystem;
                
                // åˆå§‹åŒ–æ—¶é—´æ˜¾ç¤º
                function updateTime() {
                    const now = new Date();
                    const timeString = now.toLocaleTimeString('zh-CN', {
                        hour: '2-digit',
                        minute: '2-digit',
                        second: '2-digit'
                    });
                    const elements = document.querySelectorAll('.time-display');
                    elements.forEach(el => {
                        if (el.id !== 'signalTime') {
                            el.textContent = timeString;
                        }
                    });
                }
                
                setInterval(updateTime, 1000);
                updateTime();
            });

            console.log('âœ… æ™ºèƒ½äº¤æ˜“ç³»ç»Ÿä»£ç åŠ è½½å®Œæˆ');
        </script>
    </div>
</body>
</html>